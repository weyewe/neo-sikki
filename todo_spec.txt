GroupLoan#close => split the compulsory savings to all member. round up to 500 IDR 
	#copy this rounding up from kkims
	
Before group_loan#close, they can create GroupLoanBadDebtPayment => for the uncollectibles 


TODO:
1. test the round up mechanism in the group loan default payment
2. 


What if in the same week, there are all those cases:
1. Member Deceased
2. Member Run Away
3. Member Uncollectible Amount
4. Member Premature Clearance 

Solution:

# Default Payment has many entries.the sum of all entries are the amount receivable . 
# choose: heavy data or heavy logic? 
# default payment entry is locked to the weekly_collection 
# default payment source 
1. Deactive deceased member << he doesn't have to pay for default payment. And default payment is assumed to be fulfilled. 
2. Deactivate member run away  + create uncollectible << it will change the default amount receivable 
3. Member premature clearance will need to bear the default amount from run_away and uncollectible 	
			Member C. 

How about the premature clearance is happening in week 3. 
In week 4, there is uncollectible >> The uncollectible default amount will not be burneded to the "Member C"

The information about default_loan amount_receivable is encompassing. 
If a member wants to
cancel his membership: just pay the default amount and the principal. Then, he is free 

SOP:
1. Create deceased member
2. Create Member run away
3. Create uncollectible loans 
4. confirm weekly collection
5. create GroupLoanPrematureClearancePayment << it means that the member has to pay for the current week
	If it has been paid, then the premature clearance can be done 
	
	
Confirmation is not needed. We have to enforce the SOP. However, what if they do the same shit? 

# SPEC this shit! 
# uncollectibe can't be created if there is premature clearance payment. 
# deceased member can't be created if there is premature clearance payment 
# run_away can't be created if there is premature clearance payment  => uniq glm 
# maintain uniqueness of premature clearance payment => uniq glm. 


Todo: 
continue with the mix_uncollectible_and_premature_clearance_spec.rb :
week 2 : 1 uncollectible
week 3 : 1 premature_clearance
week 4 : 1 uncollectible  << spec this ! : the amount of $$ is divided among active members. 
		SHIT. we have a problem over  here. 
		
			Total amount = total default - default_payment_cleared , splitted to all members


Success spec. ,

What are the other concern? 
run away (on the same week, or end_of_cycle), deceased, uncollectible, premature_clearance 



# the spec is done.. 
#	next step: UI work

how should the UI be done? 
0. Corner Cases 
	a. Create deceased member => we haven't created the payment 
	b. Create premature clearance
	c. Create RunAwayMember
	d. Create Uncollectible 
	
1. Master Data   => priority #1 
	a. create the User + add role 
	b. Create Group Loan Product
	c. Create Member 
	
	
2. Group Loan   => priority # 2 
	a. Create the GroupLoan  => assign group_leader
	b. Create GroupLoanMembership  (add group loan product) 
	c. Start GroupLoan => print the pdf (member list)
	c. disburse loan => prior to this, they can deactivate member. (haven't coded this)
	
3. Weekly Payment Cycle   => priority #3 

4. Savings => create savings, create withdrawal (savings_account)


============================ the segmentation 
1. Loan Management
	1.1 Setup Loan: GroupLoanProduct, GroupLoan(create + start + select), GroupLoanMembership, 
									assign group loan to the AccountOfficer 
	
	1.2 Operational: Deactivate GLM prior to LoanDisbursement, Perform Disbursement << admin
									Add Uncollectible,
									Confirm Weekly Collection,
									See DefaultPayment report 
		
	
2. Office Management 
	2.1.	Create User 
	2.2.	See report  (low priority) => Loan progress. How many loan in the 25% percentile. How many in 50% percentile, how many in 75-100?  => How can we measure completion? from the progress 
	
3. Central Admin 
	3.1 Corner Cases : Deceased Member, Run Away member (fatal)
	
	
	TODO: update default payment ON run_away creation, deceased member, and uncollectible. << Create, Update, Destroy. It will break some spec. 
	
	
	RUN AWAY = deactivate member
	Deceased = deactivate member >> ok. perform 3 updates. 
	
	
	
STILL premature clearance.. if there is run-away member in week 3, end_of_cycle payment, and premature clearance in week 2, how can we calculate the clearance payment amount ? 
		=> clearance_amount == principal*weeks_left + default payment 

If there is run-away in week 2, weekly_payment, and premature clearance in week 3, how can we calculate the clearance payment amount? 
		=> clearance_amount = principal*weeks_left + default_payment + sum_of_all_weekly_from run_away that is paid weekly by his payment clearance application week / active_group_loan_memberships including him 
		
		
		
# 	@group_loan_run_away_receivable.update the fucking amount. 


===================== run_away mixed with premature clearance 

Total weeks == 8 weeks
week 2 == run away , member C  => weekly payment  (not end of cycle) 
week 3 == premature_clearnce , member D pays full week 3 payment + contribution for week 3 run away.  
					premature_clearance_amount: 	5* principal + 
										5 weeks * weekly_run_away_amount / 7  (himself included) << rounded_up 
in the premature_clearane => extract_weekly_payment_share				
										
On week 4 = each active member pay for run_away, adjusted after the premature_clearance 

extract_weekly_run_away amount = GroupLoan.rounding_up( 
			total_weekly_run_away - premature_weekly_for_single_group, BigDecimal('500')
			) 
			
			
Next thing to be tested: what if run_away, uncollectible, deceased, and premature clearance is happening
in the same week?  
		=> We need to arrange the priority to maximize the amount recovered.

Deceased => adjust the default resolution pool   => after create, group_loan.update_default_amount 
Uncollectible => adjust the default resolution pool => after create , group_loan.update_default_amount

 
Run Away => Adjust the default resolution pool   => after_create, group_loan.update_default amount
					after_update => group_loan.update_default_amount => policy is made on the spot. 
					
premature clearance  << last one. After all defaults are summed up.  => update amount makes no difference. 
				since premature clearance won't add to default_amount.amount_receivable

Pretty much done.. do the spec! 



========= okay, group loan can't be confirmed if there are uncollectible payment. Extract the god-damned uncollectible.

=======> what if compulsory savings is not enough for the end-of-cycle default payment? bad debt expense


=> Done.. we have to reboot our test.


# on default creation: add the end_of_cycle default amount 
1. Test the normal cycle: loan disbursement => weekly payment => close group loan => withdraw remaining compulsory savings   [DON't PORT]... yeah baby.. withdraw the remaining compulsory savings. 

2. Test the Uncollectible. 
	Loan Disbursement => weekly payment => can't close group loan if there is uncollectible => close group loan => withdraw remaining compulsory savings 
	
3. Test the run away member => weekly resolution 
														=> end of cycle resolution 
														
		On weekly resolution: amount of $$ received by the cashier must be (active_members + run_away_weekly_resolution) * each principle payment
		
		On end_of_cycle resolution: amount of $$ == active_members + run_away_weekly_resolution 
		
		
4. Test the premature clearance 

5. Test the premature_clearance + run_away member (end_of_cycle and weekly_resolution)

6. Test the combination cases. 

7. DONE. 

		

